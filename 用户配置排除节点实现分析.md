# MiSub 项目中用户配置排除订阅节点的实现分析

## 概述

MiSub 项目实现了一个灵活且强大的用户配置节点过滤系统，允许用户通过配置规则来精确控制哪些节点会被包含在最终的订阅输出中。该功能支持两种工作模式：黑名单模式（排除匹配项）和白名单模式（只保留匹配项）。

## 实现架构

### 1. 前端用户界面 (src/components/Dashboard.vue)

#### 配置入口
- **位置**: 订阅编辑模态框中的"包含/排除节点"字段
- **组件**: `<textarea>` 元素，ID为 `sub-edit-exclude`
- **数据绑定**: `v-model="editingSubscription.exclude"`

#### 用户界面特性
```vue
<textarea 
  id="sub-edit-exclude" 
  v-model="editingSubscription.exclude"
  placeholder="[排除模式 (默认)]&#10;proto:vless,trojan&#10;(过期|官网)&#10;---&#10;[包含模式 (只保留匹配项)]&#10;keep:(香港|HK)&#10;keep:proto:ss"
  rows="5" 
  class="..."
>
</textarea>
<p class="text-xs text-gray-400 mt-1">每行一条规则。使用 `keep:` 切换为白名单模式。</p>
```

#### 数据初始化
```javascript
const handleAddSubscription = () => {
  editingSubscription.value = { 
    name: '', 
    url: '', 
    enabled: true, 
    exclude: '' // 新增的 exclude 字段
  };
};
```

### 2. 数据存储结构 (src/composables/useSubscriptions.js)

#### 订阅对象结构
每个订阅对象都包含 `exclude` 属性：
```javascript
function initializeSubscriptions(subsData) {
  subscriptions.value = (subsData || []).map(sub => ({
    ...sub,
    id: sub.id || crypto.randomUUID(),
    enabled: sub.enabled ?? true,
    nodeCount: sub.nodeCount || 0,
    isUpdating: false,
    userInfo: sub.userInfo || null,
    exclude: sub.exclude || '', // 存储用户配置的过滤规则
  }));
}
```

### 3. 后端处理逻辑 (functions/[[path]].js)

#### 核心过滤函数
过滤逻辑位于 `generateCombinedNodeList` 函数中（第897-980行）：

```javascript
// [核心重構] 引入白名單 (keep:) 和黑名單 (exclude) 模式
if (sub.exclude && sub.exclude.trim() !== '') {
    const rules = sub.exclude.trim().split('\n').map(r => r.trim()).filter(Boolean);
    const keepRules = rules.filter(r => r.toLowerCase().startsWith('keep:'));
    
    if (keepRules.length > 0) {
        // 白名单模式处理
    } else {
        // 黑名单模式处理
    }
}
```

## 两种工作模式详解

### 1. 黑名单模式（排除模式）- 默认模式

**工作原理**: 匹配规则的节点会被排除，其他节点保留

#### 规则类型：

**A. 协议过滤**
```
proto:vless,trojan,ss
```
- 格式：`proto:` + 协议列表（逗号分隔）
- 功能：排除指定协议的节点
- 支持的协议：ss, ssr, vmess, vless, trojan, hysteria 等

**B. 名称过滤**
```
(过期|官网|测试)
Hong Kong
```
- 格式：正则表达式模式
- 功能：排除名称匹配模式的节点
- 支持：正则表达式语法，大小写不敏感

#### 实现逻辑：
```javascript
// 黑名单模式 (Exclusion Mode)
const protocolsToExclude = new Set();
const nameRegexParts = [];

rules.forEach(rule => {
    if (rule.toLowerCase().startsWith('proto:')) {
        const protocols = rule.substring('proto:'.length).split(',').map(p => p.trim().toLowerCase());
        protocols.forEach(p => protocolsToExclude.add(p));
    } else {
        nameRegexParts.push(rule);
    }
});

const nameRegex = nameRegexParts.length > 0 ? new RegExp(nameRegexParts.join('|'), 'i') : null;

validNodes = validNodes.filter(nodeLink => {
    // 检查协议是否在排除列表中
    const protocolMatch = nodeLink.match(/^(.*?):\/\//);
    const protocol = protocolMatch ? protocolMatch[1].toLowerCase() : '';
    if (protocolsToExclude.has(protocol)) {
        return false; // 排除
    }

    // 检查节点名称是否匹配排除模式
    if (nameRegex) {
        const hashIndex = nodeLink.lastIndexOf('#');
        if (hashIndex !== -1) {
            try {
                const nodeName = decodeURIComponent(nodeLink.substring(hashIndex + 1));
                if (nameRegex.test(nodeName)) {
                    return false; // 排除
                }
            } catch (e) { /* 忽略解码错误 */ }
        }
    }
    return true; // 保留
});
```

### 2. 白名单模式（包含模式）- keep: 前缀

**工作原理**: 只保留匹配规则的节点，其他节点全部排除

#### 规则格式：
```
keep:(香港|HK|Hong Kong)
keep:proto:ss,vmess
keep:台湾
```

#### 实现逻辑：
```javascript
// 白名单模式 (Inclusion Mode)
const nameRegexParts = [];
const protocolsToKeep = new Set();

keepRules.forEach(rule => {
    const content = rule.substring('keep:'.length).trim();
    if (content.toLowerCase().startsWith('proto:')) {
        const protocols = content.substring('proto:'.length).split(',').map(p => p.trim().toLowerCase());
        protocols.forEach(p => protocolsToKeep.add(p));
    } else {
        nameRegexParts.push(content);
    }
});

const nameRegex = nameRegexParts.length > 0 ? new RegExp(nameRegexParts.join('|'), 'i') : null;

validNodes = validNodes.filter(nodeLink => {
    // 检查协议是否在保留列表中
    const protocolMatch = nodeLink.match(/^(.*?):\/\//);
    const protocol = protocolMatch ? protocolMatch[1].toLowerCase() : '';
    if (protocolsToKeep.has(protocol)) {
        return true; // 保留
    }

    // 检查节点名称是否匹配保留模式
    if (nameRegex) {
        const hashIndex = nodeLink.lastIndexOf('#');
        if (hashIndex !== -1) {
            try {
                const nodeName = decodeURIComponent(nodeLink.substring(hashIndex + 1));
                if (nameRegex.test(nodeName)) {
                    return true; // 保留
                }
            } catch (e) { /* 忽略解码错误 */ }
        }
    }
    return false; // 白名单模式下，不匹配则排除
});
```

## 技术实现细节

### 1. 节点名称提取
```javascript
const hashIndex = nodeLink.lastIndexOf('#');
if (hashIndex !== -1) {
    try {
        const nodeName = decodeURIComponent(nodeLink.substring(hashIndex + 1));
        // 使用解码后的节点名称进行匹配
    } catch (e) { 
        // 忽略URL解码错误，容错处理
    }
}
```

### 2. 协议提取
```javascript
const protocolMatch = nodeLink.match(/^(.*?):\/\//);
const protocol = protocolMatch ? protocolMatch[1].toLowerCase() : '';
```

### 3. 正则表达式构建
```javascript
// 将多个规则合并为一个正则表达式，使用 OR 逻辑
const nameRegex = nameRegexParts.length > 0 ? new RegExp(nameRegexParts.join('|'), 'i') : null;
```

## 使用示例

### 示例1：排除特定协议和关键词
```
proto:vless,trojan
(过期|到期|官网|测试)
```
效果：排除所有 vless 和 trojan 协议的节点，以及名称包含"过期"、"到期"、"官网"、"测试"的节点。

### 示例2：只保留香港 SS 节点
```
keep:(香港|HK|Hong Kong)
keep:proto:ss
```
效果：只保留协议为 ss 或名称包含香港相关关键词的节点。

### 示例3：混合使用（注意：不推荐）
```
keep:(香港|HK)
proto:trojan
```
效果：由于存在 keep: 规则，会进入白名单模式，只保留名称包含香港的节点。proto:trojan 规则会被忽略。

## 优势特性

1. **双模式支持**: 黑名单和白名单模式满足不同需求
2. **多类型过滤**: 支持协议和名称两种过滤维度
3. **正则表达式**: 支持复杂的模式匹配
4. **容错处理**: URL解码错误不会影响整体处理
5. **大小写不敏感**: 提高用户体验
6. **多规则组合**: 支持同时使用多个过滤规则
7. **实时生效**: 规则修改后立即在订阅生成时生效

## 用户体验设计

1. **直观的界面**: 清楚的标签和帮助文本
2. **示例驱动**: placeholder 提供了完整的使用示例
3. **模式说明**: 明确区分黑名单和白名单模式
4. **容错性**: 错误的规则不会导致系统崩溃
5. **即时反馈**: 规则修改后可以立即在订阅中看到效果

这个实现为用户提供了极大的灵活性，可以精确控制订阅输出的内容，满足各种复杂的使用场景。